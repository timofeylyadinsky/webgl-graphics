<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WEBGL</title>
    <link rel="stylesheet" href="./style.css">
</head>
<body onload="start()">
  <canvas id="canvas">
    Your browser doesn't appear to support the HTML5
    <code>&lt;canvas&gt;</code> element.
  </canvas>
  <table>
    <tr>
      <td>Field Of View</td>
      <td>
          <input type="range" class="slider" id="fieldOfView">
      </td>
    </tr>
    <tr>
      <td>Move X</td>
      <td>
          <input type="range" class="slider" id="moveX">
      </td>
      <td>
          <input type="number" step="1" id="moveXOut">
      </td>
  </tr>
  <tr>
      <td>Move Y</td>
      <td>
          <input type="range" class="slider" id="moveY">
      </td>
      <td>
          <input type="number" step="1" id="moveYOut">
      </td>
  </tr>
  <tr>
    <td>Move Z</td>
    <td>
        <input type="range" class="slider" id="moveZ">
    </td>
    <td>
        <input type="number" step="1" id="moveZOut">
    </td>
</tr>
  <tr>
      <td>Rotation X</td>
      <td>
          <input type="range" class="slider" id="angleX">
      </td>
  </tr>
  <tr>
    <td>Rotation Y</td>
    <td>
        <input type="range" class="slider" id="angleY">
    </td>
</tr>
<tr>
  <td>Rotation Z</td>
  <td>
      <input type="range" class="slider" id="angleZ">
  </td>
</tr>
  </table>
  <script  id="vertex-shader-3d" type="notjs">
    attribute vec4 a_position;
    attribute vec3 a_normal;
    attribute vec2 a_texcoord;

    uniform vec3 u_lightWorldPosition[2];
    uniform vec3 u_viewWorldPosition;

    uniform mat4 u_world;
    uniform mat4 u_worldViewProjection;
    uniform mat4 u_worldInverseTranspose;

    varying vec3 v_normal;

    varying vec3 v_surfaceToLight;
    varying vec3 v_surfaceToLight2;
    varying vec3 v_surfaceToView;

    varying vec2 v_texcoord;


    void main() {
    // Multiply the position by the matrix.
    gl_Position = u_worldViewProjection * a_position;

    // orient the normals and pass to the fragment shader
    v_normal = mat3(u_worldInverseTranspose) * a_normal;

    // compute the world position of the surfoace
    vec3 surfaceWorldPosition = (u_world * a_position).xyz;

    // compute the vector of the surface to the light
    // and pass it to the fragment shader
    // v_surfaceToLight = dot(u_lightWorldPosition[0], u_lightWorldPosition[1]) - surfaceWorldPosition;
    v_surfaceToLight = u_lightWorldPosition[0] - surfaceWorldPosition;
    v_surfaceToLight2 = u_lightWorldPosition[1] - surfaceWorldPosition;
    v_surfaceToView = u_viewWorldPosition - surfaceWorldPosition;
    
    v_texcoord = a_texcoord;
}
  </script>
  <script  id="fragment-shader-3d" type="notjs">
    precision mediump float;

    // Passed in from the vertex shader.
    varying vec3 v_normal;
    varying vec3 v_surfaceToLight;
    varying vec3 v_surfaceToLight2;
    varying vec3 v_surfaceToView;

    varying vec2 v_texcoord;

    uniform sampler2D u_texture;
    
    uniform vec4 u_color;
    uniform float u_shininess;
    
    
    void main() {
      // because v_normal is a varying it's interpolated
      // so it will not be a unit vector. Normalizing it
      // will make it a unit vector again
      vec3 normal = normalize(v_normal);
    
      vec3 surfaceToLightDirection = normalize(v_surfaceToLight);
      vec3 surfaceToLightDirection2 = normalize(v_surfaceToLight2);

      vec3 surfaceToViewDirection = normalize(v_surfaceToView);
      vec3 halfVector = normalize(surfaceToLightDirection + surfaceToViewDirection);
      vec3 halfVector2 = normalize(surfaceToLightDirection2 + surfaceToViewDirection);
    
      float light = dot(normal, surfaceToLightDirection);
      float light2 = dot(normal, surfaceToLightDirection2);

      float specular = 0.0;
      if (light > 0.0) {
        specular = pow(dot(normal, halfVector), u_shininess);
      }

      
      float specular2 = 0.0;
      if (light2 > 0.0) {
        specular2 = pow(dot(normal, halfVector2), u_shininess);
      }
    
      gl_FragColor = texture2D(u_texture, v_texcoord);
      //gl_FragColor = u_color;
    
      // Lets multiply just the color portion (not the alpha)
      // by the light
      vec3 color = gl_FragColor.rgb * light + gl_FragColor.rgb * light2;
      //gl_FragColor.rgb *= light * u_lightColor;
      gl_FragColor.rgb += color + specular + specular2;
      //gl_FragColor.rgb *= light2;
      //gl_FragColor.rgb = color + specular;// + specular2;
    }
  </script>
  <script src="https://webglfundamentals.org/webgl/resources/webgl-utils.js"></script>
  <script src="https://webglfundamentals.org/webgl/resources/m4.js"></script>
  <!-- <script src="matrix.js"></script> -->
  <script src="script.js"></script>

</body>
</body>
</html>